use eframe::egui;
use egui::{Color32, RichText};
use std::sync::Arc;
use std::collections::VecDeque;
use egui_mobius_reactive::{Dynamic, Derived, ReactiveValue};


pub use crate::logger::colors::LogColors;

/// LogType
///
/// This enum is used to categorize the type of log entry
/// in the terminal widget. This is used to color code the
/// log entries.
///
/// The Default variant is used for general log entries
/// that do not fit into the other categories.
///
/// The Timestamp variant is used to indicate that the log
/// entry is a timestamped message.
///
/// The Slider, OptionA, OptionB, OptionC, CustomEvent, and
/// RunStop variants are used to categorize log entries
/// that are generated by the respective widgets.
///
/// The Slider variant is used for logs generated by the
/// slider widget.
///
/// The OptionA, OptionB, and OptionC variants are used for
/// logs generated by the option widgets.
///
/// The CustomEvent variant is used for logs generated by
/// custom events.
///
/// The RunStop variant is used for logs generated by the
/// run/stop widget.    
/// 
#[derive(Clone, Copy, PartialEq)]
pub enum LogType {
    Checkbox,
    Slider,
    OptionA,
    OptionB,
    OptionC,
    CustomEvent,
    RunStop,
    Default,
    Timestamp,
    Primary,
    Secondary,
}
/// Debug for LogType
/// 
/// This is used to display the LogType in the terminal widget
/// 
impl std::fmt::Debug for LogType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LogType::Checkbox => write!(f, "Checkbox"),
            LogType::Primary => write!(f, "Primary"),
            LogType::Secondary => write!(f, "Secondary"),
            LogType::Slider => write!(f, "Slider"),
            LogType::OptionA => write!(f, "Fat32"),
            LogType::OptionB => write!(f, "ExFat"),
            LogType::OptionC => write!(f, "Option C"), // Keep for backward compatibility
            LogType::CustomEvent => write!(f, "Wipe (dd)"),
            LogType::RunStop => write!(f, "Format"),
            LogType::Default => write!(f, "Default"),
            LogType::Timestamp => write!(f, "Timestamp"),
        }
    }
}


pub const MAX_LOGS: usize = 1000; // Maximum number of logs to keep in memory
#[allow(dead_code)]
#[derive(Clone)]
pub struct TerminalWidget {
    pub logs          : Dynamic<VecDeque<(String, LogType)>>,
    pub colors        : Dynamic<LogColors>,
    pub rich_text     : Derived<Vec<RichText>>,
    pub repaint       : egui::Context,
}

impl TerminalWidget {
    /// Add a new log entry, trimming old logs if necessary
    pub fn add_log(&mut self, msg: String, log_type: LogType) {
        let mut logs = self.logs.get();
        logs.push_back((msg, log_type));
        
        // Maintain circular buffer - remove oldest entry if at capacity
        if logs.len() >= MAX_LOGS {
            logs.pop_front();
        }
        
        self.logs.set(logs);
        self.repaint.request_repaint();
    }

    pub fn new(repaint: egui::Context, colors: LogColors) -> Self {
        let logs = Dynamic::new(VecDeque::with_capacity(MAX_LOGS));
        let colors = Dynamic::new(colors);

        // Create derived rich text from logs and colors
        let logs_clone = logs.clone();
        let colors_clone = colors.clone();
        let deps = [
            Arc::new(logs.clone()) as Arc<dyn ReactiveValue>,
            Arc::new(colors.clone()) as Arc<dyn ReactiveValue>
        ];
        let rich_text = Derived::new(
            &deps,
            move || {
                let logs = logs_clone.get();
                let colors = colors_clone.get();
                logs.iter()
                    .rev()
                    .map(|(msg, log_type)| {
                        let color = match log_type {
                            LogType::Slider => colors.slider,
                            LogType::OptionA => colors.option_a,
                            LogType::OptionB => colors.option_b,
                            LogType::OptionC => colors.option_c,
                            LogType::CustomEvent => colors.custom_event,
                            LogType::Checkbox => colors.custom_event, // Use custom_event color for checkbox
                            LogType::RunStop => colors.run_stop_log,
                            LogType::Timestamp => colors.time_format,
                            LogType::Default => Color32::WHITE,
                            LogType::Primary => colors.clock,  // Use clock color for primary events
                            LogType::Secondary => colors.custom_event,  // Use custom_event color for secondary events
                        };
                        RichText::new(msg).color(color)
                    })  
                    .collect()
            }); 

        Self {
            logs,
            colors,
            rich_text,
            repaint,

        }
    }


    /// Updates the color scheme for the terminal
    pub fn update_colors(&mut self, new_colors: LogColors) {
        // Update the colors
        self.colors.set(new_colors);

        // Force a repaint to show the changes
        self.repaint.request_repaint();
    }
}
